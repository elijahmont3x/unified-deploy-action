#!/bin/bash
#
# uds-docker.sh - Docker integration for Unified Deployment System
#
# This module provides functions for Docker container and compose management

# Avoid loading multiple times
if [ -n "$UDS_DOCKER_LOADED" ]; then
  return 0
fi
UDS_DOCKER_LOADED=1

# Check if port is available
uds_is_port_available() {
  local port="$1"
  local host="${2:-localhost}"
  
  # Try netstat if available
  if command -v netstat &>/dev/null; then
    if netstat -tuln | grep -q ":$port "; then
      return 1
    fi
  # Try ss if available
  elif command -v ss &>/dev/null; then
    if ss -tuln | grep -q ":$port "; then
      return 1
    fi
  # Fallback to direct check
  else
    if ! (echo >/dev/tcp/$host/$port) 2>/dev/null; then
      return 0
    else
      return 1
    fi
  fi
  
  return 0
}

# Find an available port starting from a base port
uds_find_available_port() {
  local base_port="$1"
  local max_port="${2:-65535}"
  local increment="${3:-1}"
  local host="${4:-localhost}"
  
  local current_port="$base_port"
  
  while [ "$current_port" -le "$max_port" ]; do
    if uds_is_port_available "$current_port" "$host"; then
      echo "$current_port"
      return 0
    fi
    
    current_port=$((current_port + increment))
  done
  
  return 1
}

# Resolve port conflicts automatically
uds_resolve_port_conflicts() {
  local port="$1"
  local app_name="$2"
  
  if uds_is_port_available "$port"; then
    echo "$port"
    return 0
  fi
  
  if [ "${PORT_AUTO_ASSIGN:-true}" = "true" ]; then
    uds_log "Port $port is already in use, finding an alternative" "warning"
    
    local available_port=$(uds_find_available_port "$port")
    
    if [ -n "$available_port" ]; then
      uds_log "Using alternative port: $available_port" "warning"
      echo "$available_port"
      return 0
    else
      uds_log "Failed to find an available port" "error"
      return 1
    fi
  else
    uds_log "Port $port is already in use and auto-assign is disabled" "error"
    return 1
  fi
}

# Generate a docker-compose.yml file
uds_generate_compose_file() {
  local app_name="$1"
  local image="$2"
  local tag="$3"
  local port="$4"
  local output_file="$5"
  local env_vars="${6:-{}}"
  local volumes="${7:-}"
  local use_profiles="${8:-true}"
  local extra_hosts="${9:-}"
  local compose_version="${10:-3.8}"

  uds_log "Generating docker-compose.yml for $app_name" "debug"

  # Apply secure permissions to the output file directory
  mkdir -p "$(dirname "$output_file")"
  uds_secure_permissions "$(dirname "$output_file")" 700

  # Start the compose file
  cat > "$output_file" << EOL
# Generated by Unified Deployment System
version: '${compose_version}'

services:
EOL

  # For multiple images, create multiple services
  if [[ "$image" == *","* ]]; then
    # Split comma-separated list
    IFS=',' read -ra IMAGES <<< "$image"
    IFS=',' read -ra PORTS <<< "$port"
    
    for i in "${!IMAGES[@]}"; do
      local img_clean=$(echo "${IMAGES[$i]}" | tr -d ' ')
      # Extract service name from image, handling complex image paths
      local service_name=$(echo "$img_clean" | sed -E 's|.*/||' | sed -E 's|:.*||' | tr '[:upper:]' '[:lower:]')
      
      # If service name is empty or invalid, generate a default one
      if [ -z "$service_name" ] || [[ "$service_name" =~ [^a-zA-Z0-9_-] ]]; then
        service_name="service-$((i+1))"
      fi
      
      local service_port=${PORTS[$i]:-3000}
      
      # Add the service configuration
      cat >> "$output_file" << EOL
  ${service_name}:
    image: ${img_clean}:${tag}
    container_name: ${app_name}-${service_name}
EOL
      if [ "$use_profiles" = "true" ]; then
        cat >> "$output_file" << EOL
    profiles:
      - app
EOL
      fi
      
      cat >> "$output_file" << EOL
    restart: unless-stopped
EOL
      
      # Add ports section if port is specified
      if [ -n "$service_port" ]; then
        cat >> "$output_file" << EOL
    ports:
EOL
        # Handle port mapping format (host:container)
        if [[ "$service_port" == *":"* ]]; then
          local host_port=$(echo "$service_port" | cut -d: -f1)
          local container_port=$(echo "$service_port" | cut -d: -f2)
          echo "      - \"${host_port}:${container_port}\"" >> "$output_file"
        else
          echo "      - \"${service_port}:${service_port}\"" >> "$output_file"
        fi
      fi
      
      # Add environment variables
      _add_environment_variables "$env_vars" "$output_file" "$service_name"
      
      # Add volumes
      _add_volumes "$volumes" "$output_file" "$service_name"
      
      # Add extra hosts
      _add_extra_hosts "$extra_hosts" "$output_file"
      
      # Add networks
      echo "    networks:" >> "$output_file"
      echo "      - ${app_name}-network" >> "$output_file"
    done
  else
    # Single service
    cat >> "$output_file" << EOL
  app:
    image: ${image}:${tag}
    container_name: ${app_name}-app
EOL
    if [ "$use_profiles" = "true" ]; then
      cat >> "$output_file" << EOL
    profiles:
      - app
EOL
    fi
    
    cat >> "$output_file" << EOL
    restart: unless-stopped
EOL
    
    # Add ports section if port is specified
    if [ -n "$port" ]; then
      cat >> "$output_file" << EOL
    ports:
EOL
      # Handle port mapping format (host:container)
      if [[ "$port" == *":"* ]]; then
        local host_port=$(echo "$port" | cut -d: -f1)
        local container_port=$(echo "$port" | cut -d: -f2)
        echo "      - \"${host_port}:${container_port}\"" >> "$output_file"
      else
        echo "      - \"${port}:${port}\"" >> "$output_file"
      fi
    fi
    
    # Add environment variables
    _add_environment_variables "$env_vars" "$output_file" "app"
    
    # Add volumes
    _add_volumes "$volumes" "$output_file" "app"
    
    # Add extra hosts
    _add_extra_hosts "$extra_hosts" "$output_file"
    
    # Add networks
    echo "    networks:" >> "$output_file"
    echo "      - ${app_name}-network" >> "$output_file"
  fi

  # Add network configuration
  cat >> "$output_file" << EOL

networks:
  ${app_name}-network:
    name: ${app_name}-network
EOL

  # Secure the compose file
  uds_secure_permissions "$output_file" 600
  
  uds_log "Generated docker-compose.yml at $output_file" "debug"
}

# Helper function to add environment variables to compose file
_add_environment_variables() {
  local env_vars="$1"
  local output_file="$2"
  local service_name="$3"
  
  # Add environment variables if provided
  if [ "$env_vars" != "{}" ]; then
    echo "    environment:" >> "$output_file"
    
    # Parse env_vars JSON safely to handle different formats
    if echo "$env_vars" | jq -e 'type == "object"' > /dev/null 2>&1; then
      # Extract service-specific env vars if available
      if echo "$env_vars" | jq -e "has(\"$service_name\")" > /dev/null 2>&1; then
        # Service-specific environment variables
        echo "$env_vars" | jq -r ".[\"$service_name\"] | to_entries[] | \"      - \" + .key + \"=\" + (.value | tostring)" >> "$output_file"
      else
        # Global environment variables for all services
        echo "$env_vars" | jq -r 'to_entries[] | "      - " + .key + "=" + (.value | tostring)' >> "$output_file"
      fi
    else
      uds_log "Warning: env_vars is not a valid JSON object, using empty environment" "warning"
    fi
  fi
}

# Helper function to add volumes to compose file
_add_volumes() {
  local volumes="$1"
  local output_file="$2"
  local service_name="$3"
  
  # Add volumes if provided
  if [ -n "$volumes" ]; then
    echo "    volumes:" >> "$output_file"
    
    # Handle both comma-separated string and JSON array formats
    if [[ "$volumes" == "["* ]]; then
      # JSON array format
      echo "$volumes" | jq -r '.[] | "      - " + .' >> "$output_file"
    else
      # Comma-separated string format
      IFS=',' read -ra VOLUME_MAPPINGS <<< "$volumes"
      for volume in "${VOLUME_MAPPINGS[@]}"; do
        local vol_clean=$(echo "$volume" | tr -d ' ')
        echo "      - $vol_clean" >> "$output_file"
      done
    fi
  fi
}

# Helper function to add extra hosts to compose file
_add_extra_hosts() {
  local extra_hosts="$1"
  local output_file="$2"
  
  # Add extra hosts if provided
  if [ -n "$extra_hosts" ]; then
    echo "    extra_hosts:" >> "$output_file"
    
    # Handle both comma-separated string and JSON array formats
    if [[ "$extra_hosts" == "["* ]]; then
      # JSON array format
      echo "$extra_hosts" | jq -r '.[] | "      - " + .' >> "$output_file"
    else
      # Comma-separated string format
      IFS=',' read -ra HOST_ENTRIES <<< "$extra_hosts"
      for host in "${HOST_ENTRIES[@]}"; do
        local host_clean=$(echo "$host" | tr -d ' ')
        echo "      - $host_clean" >> "$output_file"
      done
    fi
  fi
}

# Pull Docker images with improved error handling
uds_pull_docker_images() {
  local images="$1"
  local tag="$2"
  local skip_pull="${3:-false}"
  
  if [ "$skip_pull" = "true" ]; then
    uds_log "Skipping Docker image pull as requested" "info"
    return 0
  fi
  
  uds_log "Pulling Docker images..." "info"
  
  # Handle multiple images if specified
  if [[ "$images" == *","* ]]; then
    IFS=',' read -ra IMAGES_ARRAY <<< "$images"
    
    for img in "${IMAGES_ARRAY[@]}"; do
      local img_clean=$(echo "$img" | tr -d ' ')
      
      uds_log "Pulling image: $img_clean:$tag" "info"
      
      # Pull with retry logic
      local attempts=0
      local max_attempts=3
      local pull_success=false
      
      while [ $attempts -lt $max_attempts ] && [ "$pull_success" = "false" ]; do
        if docker pull "$img_clean:$tag"; then
          pull_success=true
        else
          attempts=$((attempts + 1))
          if [ $attempts -lt $max_attempts ]; then
            uds_log "Pull failed, retrying ($attempts/$max_attempts)..." "warning"
            sleep 3
          fi
        fi
      done
      
      if [ "$pull_success" = "false" ]; then
        uds_log "Failed to pull image $img_clean:$tag after $max_attempts attempts" "error"
        return 1
      fi
    done
  else
    # Single image
    uds_log "Pulling image: $images:$tag" "info"
    
    # Pull with retry logic
    local attempts=0
    local max_attempts=3
    local pull_success=false
    
    while [ $attempts -lt $max_attempts ] && [ "$pull_success" = "false" ]; do
      if docker pull "$images:$tag"; then
        pull_success=true
      else
        attempts=$((attempts + 1))
        if [ $attempts -lt $max_attempts ]; then
          uds_log "Pull failed, retrying ($attempts/$max_attempts)..." "warning"
          sleep 3
        fi
      fi
    done
    
    if [ "$pull_success" = "false" ]; then
      uds_log "Failed to pull image $images:$tag after $max_attempts attempts" "error"
      return 1
    fi
  fi
  
  uds_log "All images pulled successfully" "success"
  return 0
}

# Get container logs with proper formatting
uds_get_container_logs() {
  local container_name="$1"
  local lines="${2:-50}"
  local tail_option="${3:--n}"
  
  # Check if container exists
  if ! docker ps -a -q --filter "name=$container_name" | grep -q .; then
    uds_log "Container $container_name not found" "warning"
    return 1
  fi
  
  # Get logs with specified options
  docker logs "$container_name" $tail_option $lines 2>&1
}

# Check container health status
uds_get_container_health() {
  local container_name="$1"
  
  # Check if container exists
  if ! docker ps -a -q --filter "name=$container_name" | grep -q .; then
    uds_log "Container $container_name not found" "warning"
    return 1
  fi
  
  # Get health status
  local health_status
  health_status=$(docker inspect --format='{{if .State.Health}}{{.State.Health.Status}}{{else}}none{{end}}' "$container_name" 2>/dev/null)
  
  # If health check is not configured, check if container is running
  if [ "$health_status" = "none" ]; then
    local is_running
    is_running=$(docker inspect --format='{{.State.Running}}' "$container_name" 2>/dev/null)
    
    if [ "$is_running" = "true" ]; then
      echo "running"
    else
      echo "stopped"
    fi
  else
    echo "$health_status"
  fi
  
  return 0
}

# Execute command in container with error handling
uds_exec_container() {
  local container_name="$1"
  local command="$2"
  local capture_output="${3:-true}"
  
  # Check if container is running
  if ! docker ps -q --filter "name=$container_name" | grep -q .; then
    uds_log "Container $container_name is not running" "error"
    return 1
  fi
  
  # Execute command
  if [ "$capture_output" = "true" ]; then
    docker exec "$container_name" sh -c "$command"
  else
    docker exec "$container_name" sh -c "$command" &>/dev/null
  fi
  
  local exit_code=$?
  
  if [ $exit_code -ne 0 ]; then
    uds_log "Command failed in container $container_name: $command" "error"
    return $exit_code
  fi
  
  return 0
}

# Export functions
export -f uds_is_port_available uds_find_available_port uds_resolve_port_conflicts
export -f uds_generate_compose_file uds_pull_docker_images
export -f uds_get_container_logs uds_get_container_health uds_exec_container