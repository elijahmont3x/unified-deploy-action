#!/bin/bash
#
# uds-nginx.sh - Nginx configuration for Unified Deployment System
#
# This module provides functions for managing Nginx configurations

# Avoid loading multiple times
if [ -n "$UDS_NGINX_LOADED" ]; then
  return 0
fi
UDS_NGINX_LOADED=1

# Create an Nginx configuration
uds_create_nginx_config() {
  local app_name="$1"
  local domain="$2"
  local route_type="$3"
  local route="$4"
  local port="$5"
  local use_ssl="${6:-true}"
  
  local config_file="${UDS_NGINX_DIR}/${app_name}.conf"
  local server_name="${domain}"
  
  # Determine server_name and location based on route type
  if [ "$route_type" = "subdomain" ]; then
    if [ -n "$route" ]; then
      server_name="${route}.${domain}"
    fi
    location="/"
  else
    # Path-based routing
    if [ -n "$route" ]; then
      location="/${route}"
      # Ensure location starts with / and doesn't have trailing /
      location=$(echo "$location" | sed 's#//*#/#' | sed 's#/$##')
    else
      location="/"
    fi
  fi
  
  # Create the Nginx configuration file
  cat > "$config_file" << EOL
# Generated by Unified Deployment System
# App: ${app_name}
# Domain: ${server_name}
# Route: ${location}

server {
    listen 80;
    listen [::]:80;
    server_name ${server_name};
EOL

  # Add SSL configuration if enabled
  if [ "$use_ssl" = "true" ]; then
    cat >> "$config_file" << EOL
    
    # Redirect HTTP to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${server_name};
    
    # SSL configuration
    ssl_certificate ${UDS_CERTS_DIR}/${server_name}/fullchain.pem;
    ssl_certificate_key ${UDS_CERTS_DIR}/${server_name}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-XSS-Protection "1; mode=block";
EOL
  fi

  # Add location configuration
  cat >> "$config_file" << EOL
    
    location ${location} {
EOL

  # Strip prefix if path-based routing
  if [ "$route_type" = "path" ] && [ "$location" != "/" ]; then
    cat >> "$config_file" << EOL
        # Strip path prefix
        rewrite ^${location}(/.*)?$ $1 break;
EOL
  fi

  # Add proxy configuration
  cat >> "$config_file" << EOL
        proxy_pass http://localhost:${port};
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
    }
EOL

  # Close the server block
  if [ "$use_ssl" != "true" ]; then
    echo "}" >> "$config_file"
  fi

  uds_log "Created Nginx configuration: ${config_file}" "info"
  
  # Return the filename for reference
  echo "$config_file"
}

# Create an advanced Nginx configuration with custom options
uds_create_advanced_nginx_config() {
  local app_name="$1"
  local domain="$2"
  local route_type="$3"
  local route="$4"
  local port="$5"
  local options="${6:-{}}"
  
  local config_file="${UDS_NGINX_DIR}/${app_name}.conf"
  local server_name="${domain}"
  
  # Extract options with defaults
  local use_ssl=$(echo "$options" | jq -r '.use_ssl // true')
  local client_max_body_size=$(echo "$options" | jq -r '.client_max_body_size // "1m"')
  local custom_headers=$(echo "$options" | jq -r '.custom_headers // {}')
  local enable_compression=$(echo "$options" | jq -r '.enable_compression // true')
  local enable_caching=$(echo "$options" | jq -r '.enable_caching // false')
  local cache_time=$(echo "$options" | jq -r '.cache_time // "1h"')
  local enable_websockets=$(echo "$options" | jq -r '.enable_websockets // true')
  local enable_cors=$(echo "$options" | jq -r '.enable_cors // false')
  local cors_origin=$(echo "$options" | jq -r '.cors_origin // "*"')
  local custom_locations=$(echo "$options" | jq -r '.custom_locations // []')
  
  # Determine server_name and location based on route type
  if [ "$route_type" = "subdomain" ]; then
    if [ -n "$route" ]; then
      server_name="${route}.${domain}"
    fi
    location="/"
  else
    # Path-based routing
    if [ -n "$route" ]; then
      location="/${route}"
      # Ensure location starts with / and doesn't have trailing /
      location=$(echo "$location" | sed 's#//*#/#' | sed 's#/$##')
    else
      location="/"
    fi
  fi
  
  # Create the Nginx configuration file
  cat > "$config_file" << EOL
# Generated by Unified Deployment System
# App: ${app_name}
# Domain: ${server_name}
# Route: ${location}

server {
    listen 80;
    listen [::]:80;
    server_name ${server_name};
EOL

  # Add SSL configuration if enabled
  if [ "$use_ssl" = "true" ]; then
    cat >> "$config_file" << EOL
    
    # Redirect HTTP to HTTPS
    location / {
        return 301 https://$host$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${server_name};
    
    # SSL configuration
    ssl_certificate ${UDS_CERTS_DIR}/${server_name}/fullchain.pem;
    ssl_certificate_key ${UDS_CERTS_DIR}/${server_name}/privkey.pem;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    
    # Security headers
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains" always;
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-XSS-Protection "1; mode=block";
EOL
  fi

  # Add client max body size if specified
  cat >> "$config_file" << EOL
    
    # Client body size
    client_max_body_size ${client_max_body_size};
EOL

  # Add custom headers if specified
  if [ "$custom_headers" != "{}" ]; then
    cat >> "$config_file" << EOL
    
    # Custom headers
EOL
    
    echo "$custom_headers" | jq -r 'to_entries[] | "    add_header \(.key) \"\(.value)\" always;"' >> "$config_file"
  fi

  # Add compression if enabled
  if [ "$enable_compression" = "true" ]; then
    cat >> "$config_file" << EOL
    
    # Compression settings
    gzip on;
    gzip_comp_level 5;
    gzip_min_length 256;
    gzip_proxied any;
    gzip_vary on;
    gzip_types
        application/atom+xml
        application/javascript
        application/json
        application/ld+json
        application/manifest+json
        application/rss+xml
        application/vnd.geo+json
        application/vnd.ms-fontobject
        application/x-font-ttf
        application/x-web-app-manifest+json
        application/xhtml+xml
        application/xml
        font/opentype
        image/bmp
        image/svg+xml
        image/x-icon
        text/cache-manifest
        text/css
        text/plain
        text/vcard
        text/vnd.rim.location.xloc
        text/vtt
        text/x-component
        text/x-cross-domain-policy;
EOL
  fi

  # Add CORS if enabled
  if [ "$enable_cors" = "true" ]; then
    cat >> "$config_file" << EOL
    
    # CORS settings
    add_header 'Access-Control-Allow-Origin' '${cors_origin}' always;
    add_header 'Access-Control-Allow-Methods' 'GET, POST, OPTIONS, PUT, DELETE, PATCH' always;
    add_header 'Access-Control-Allow-Headers' 'DNT,User-Agent,X-Requested-With,If-Modified-Since,Cache-Control,Content-Type,Range,Authorization' always;
    add_header 'Access-Control-Expose-Headers' 'Content-Length,Content-Range' always;
EOL
  fi

  # Add location configuration
  cat >> "$config_file" << EOL
    
    location ${location} {
EOL

  # Strip prefix if path-based routing
  if [ "$route_type" = "path" ] && [ "$location" != "/" ]; then
    cat >> "$config_file" << EOL
        # Strip path prefix
        rewrite ^${location}(/.*)?$ $1 break;
EOL
  fi

  # Add proxy configuration
  cat >> "$config_file" << EOL
        proxy_pass http://localhost:${port};
        proxy_http_version 1.1;
EOL

  # Add websocket support if enabled
  if [ "$enable_websockets" = "true" ]; then
    cat >> "$config_file" << EOL
        # WebSocket support
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection "upgrade";
EOL
  fi

  # Add standard proxy headers
  cat >> "$config_file" << EOL
        # Proxy headers
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_cache_bypass \$http_upgrade;
EOL

  # Add caching if enabled
  if [ "$enable_caching" = "true" ]; then
    cat >> "$config_file" << EOL
        
        # Caching settings
        proxy_cache nginx_cache;
        proxy_cache_valid 200 ${cache_time};
        proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
        proxy_cache_background_update on;
        proxy_cache_lock on;
        add_header X-Cache-Status \$upstream_cache_status;
EOL
  fi

  # Close the main location block
  echo "    }" >> "$config_file"

  # Add custom locations if specified
  if [ "$(echo "$custom_locations" | jq -r 'length')" -gt 0 ]; then
    echo "" >> "$config_file"
    echo "    # Custom locations" >> "$config_file"
    
    # Process each custom location
    echo "$custom_locations" | jq -r '.[] | "    location \(.path) {\n\(.config)\n    }"' >> "$config_file"
  fi

  # Close the server block
  echo "}" >> "$config_file"

  uds_log "Created advanced Nginx configuration: ${config_file}" "info"
  
  # Return the filename for reference
  echo "$config_file"
}

# Reload Nginx configuration
uds_reload_nginx() {
  uds_log "Reloading Nginx configuration" "info"
  
  # Check if running in Docker
  if docker ps -q --filter "name=nginx-proxy" | grep -q .; then
    # Reload Nginx in the container
    docker exec nginx-proxy nginx -s reload
  else
    # Reload Nginx on the host
    nginx -s reload
  fi
  
  # Check if reload was successful
  if [ $? -eq 0 ]; then
    uds_log "Nginx configuration reloaded successfully" "success"
    return 0
  else
    uds_log "Failed to reload Nginx configuration" "error"
    return 1
  fi
}

# Verify Nginx configuration syntax
uds_verify_nginx_config() {
  local config_file="${1:-}"
  
  uds_log "Verifying Nginx configuration syntax" "info"
  
  # Check if running in Docker
  if docker ps -q --filter "name=nginx-proxy" | grep -q .; then
    # Verify in container context
    if [ -n "$config_file" ]; then
      # Copy the specific config to container for testing
      local tmpfile="/tmp/nginx_config_test_$(date +%s).conf"
      cp "$config_file" "$tmpfile"
      docker cp "$tmpfile" "nginx-proxy:/etc/nginx/conf.d/test.conf"
      rm -f "$tmpfile"
      
      # Test the specific config
      docker exec nginx-proxy nginx -t
      local result=$?
      
      # Remove test config
      docker exec nginx-proxy rm "/etc/nginx/conf.d/test.conf"
      
      return $result
    else
      # Test whole configuration
      docker exec nginx-proxy nginx -t
    fi
  else
    # Verify on host
    if [ -n "$config_file" ]; then
      nginx -t -c "$config_file"
    else
      nginx -t
    fi
  fi
  
  # Check result
  if [ $? -eq 0 ]; then
    uds_log "Nginx configuration syntax is valid" "success"
    return 0
  else
    uds_log "Nginx configuration syntax is invalid" "error"
    return 1
  fi
}

# Generate a default Nginx configuration
uds_generate_default_nginx_config() {
  local output_dir="${1:-$UDS_NGINX_DIR}"
  
  uds_log "Generating default Nginx configuration" "info"
  
  # Create the output directory if it doesn't exist
  mkdir -p "$output_dir"
  
  # Create default.conf
  local default_conf="${output_dir}/default.conf"
  
  cat > "$default_conf" << 'EOL'
# Default Nginx configuration managed by Unified Deployment System

# HTTP server
server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name _;
    
    # Let's Encrypt validation
    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }
    
    # Default response for unmatched hosts
    location / {
        return 404 "No application configured for this host.\n";
    }
}

# HTTPS server
server {
    listen 443 ssl http2 default_server;
    listen [::]:443 ssl http2 default_server;
    server_name _;
    
    # Self-signed certificate for default server
    ssl_certificate /etc/nginx/certs/default.pem;
    ssl_certificate_key /etc/nginx/certs/default.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    
    # Default response for unmatched hosts
    location / {
        return 404 "No application configured for this host.\n";
    }
}
EOL

  # Generate main nginx.conf for reference
  local nginx_conf="${output_dir}/nginx.conf"
  
  cat > "$nginx_conf" << 'EOL'
# Main Nginx configuration managed by Unified Deployment System

user  nginx;
worker_processes  auto;

error_log  /var/log/nginx/error.log warn;
pid        /var/run/nginx.pid;

events {
    worker_connections  1024;
}

http {
    include       /etc/nginx/mime.types;
    default_type  application/octet-stream;

    log_format  main  '$remote_addr - $remote_user [$time_local] "$request" '
                      '$status $body_bytes_sent "$http_referer" '
                      '"$http_user_agent" "$http_x_forwarded_for"';

    access_log  /var/log/nginx/access.log  main;

    sendfile        on;
    tcp_nopush      on;
    tcp_nodelay     on;
    keepalive_timeout  65;
    types_hash_max_size 2048;
    server_tokens   off;

    # Compression settings
    gzip              on;
    gzip_comp_level   5;
    gzip_min_length   256;
    gzip_proxied      any;
    gzip_vary         on;
    gzip_types
        application/atom+xml
        application/javascript
        application/json
        application/ld+json
        application/manifest+json
        application/rss+xml
        application/vnd.geo+json
        application/vnd.ms-fontobject
        application/x-font-ttf
        application/x-web-app-manifest+json
        application/xhtml+xml
        application/xml
        font/opentype
        image/bmp
        image/svg+xml
        image/x-icon
        text/cache-manifest
        text/css
        text/plain
        text/vcard
        text/vnd.rim.location.xloc
        text/vtt
        text/x-component
        text/x-cross-domain-policy;

    # SSL settings
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_prefer_server_ciphers on;
    ssl_ciphers EECDH+AESGCM:EDH+AESGCM;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;

    # Proxy cache settings
    proxy_cache_path /var/cache/nginx levels=1:2 keys_zone=nginx_cache:10m max_size=1g inactive=60m;
    proxy_cache_key "$scheme$request_method$host$request_uri";
    
    # Security headers
    add_header X-Content-Type-Options nosniff;
    add_header X-Frame-Options SAMEORIGIN;
    add_header X-XSS-Protection "1; mode=block";

    # Include additional configuration files
    include /etc/nginx/conf.d/*.conf;
}
EOL

  uds_log "Default Nginx configuration generated at $output_dir" "success"
  return 0
}

# Export functions
export -f uds_create_nginx_config uds_create_advanced_nginx_config
export -f uds_reload_nginx uds_verify_nginx_config uds_generate_default_nginx_config