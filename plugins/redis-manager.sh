#!/bin/bash
#
# redis-manager.sh - Redis management plugin for Unified Deployment System
#
# This plugin handles Redis setup, monitoring, and management

# Ensure the health check module is available
if [ -f "$(dirname "${BASH_SOURCE[0]}")/../scripts/uds-health.sh" ]; then
  source "$(dirname "${BASH_SOURCE[0]}")/../scripts/uds-health.sh"
fi

# Register the plugin
plugin_register_redis_manager() {
  uds_log "Registering Redis Manager plugin" "debug"
  
  # Register plugin arguments
  uds_register_plugin_arg "redis_manager" "REDIS_DATA_DIR" "${UDS_BASE_DIR}/data/redis"
  uds_register_plugin_arg "redis_manager" "REDIS_CONFIG_DIR" "${UDS_BASE_DIR}/configs/redis"
  uds_register_plugin_arg "redis_manager" "REDIS_BACKUP_ENABLED" "true"
  uds_register_plugin_arg "redis_manager" "REDIS_BACKUP_DIR" "${UDS_BASE_DIR}/backups/redis"
  uds_register_plugin_arg "redis_manager" "REDIS_MAX_MEMORY" "256mb"
  uds_register_plugin_arg "redis_manager" "REDIS_PASSWORD_ENABLED" "true"
  uds_register_plugin_arg "redis_manager" "REDIS_PORT" "6379"
  
  # Register plugin hooks
  uds_register_plugin_hook "redis_manager" "pre_deploy" "plugin_redis_prepare"
  uds_register_plugin_hook "redis_manager" "post_deploy" "plugin_redis_check"
  uds_register_plugin_hook "redis_manager" "pre_cleanup" "plugin_redis_backup"
  
  # Register dependency on persistence-manager if available
  if [ -n "${UDS_PLUGIN_REGISTRY[persistence-manager]:-}" ]; then
    uds_register_plugin_dependency "redis_manager" "persistence-manager"
  fi

  # Register service dependencies if dependency system is available
  if type uds_register_dependency &>/dev/null; then
    if [[ "$IMAGE" == *"redis"* ]]; then
      local app_name="${APP_NAME}"
      # Register this Redis instance as a dependency for any service that uses it
      # Look for REDIS_URL in environment variables of other services
      for service in $(uds_list_services); do
        local service_data=$(uds_get_service "$service")
        if [ -n "$service_data" ]; then
          local env_vars=$(echo "$service_data" | jq -r '.env_vars // {}')
          local redis_url=$(echo "$env_vars" | jq -r '.REDIS_URL // ""')
          
          if [[ "$redis_url" == *"$app_name"* ]]; then
            uds_log "Detected $service depends on $app_name based on REDIS_URL" "info"
            uds_register_dependency "$service" "$app_name"
          fi
        fi
      done
    fi
  fi
}

# Activate the plugin
plugin_activate_redis_manager() {
  uds_log "Activating Redis Manager plugin" "debug"
  
  # Create required directories
  mkdir -p "${REDIS_DATA_DIR}" "${REDIS_CONFIG_DIR}" "${REDIS_BACKUP_DIR}"
  
  # Set secure permissions
  uds_secure_permissions "${REDIS_DATA_DIR}" 700
  uds_secure_permissions "${REDIS_CONFIG_DIR}" 700
  uds_secure_permissions "${REDIS_BACKUP_DIR}" 700
}

# Prepare Redis configuration and directories
plugin_redis_prepare() {
  local app_name="$1"
  local app_dir="$2"
  
  # Only process Redis deployments
  if [[ "$IMAGE" != *"redis"* ]]; then
    return 0
  fi
  
  uds_log "Setting up Redis for $app_name" "info"
  
  # Create Redis config file if it doesn't exist
  local redis_conf="${REDIS_CONFIG_DIR}/${app_name}.conf"
  if [ ! -f "$redis_conf" ]; then
    uds_log "Creating Redis configuration for $app_name" "info"
    
    # Generate Redis password if enabled
    local redis_password=""
    if [ "${REDIS_PASSWORD_ENABLED}" = "true" ]; then
      redis_password=$(openssl rand -hex 16)
      uds_log "Generated Redis password for $app_name" "debug"
    fi
    
    # Create Redis configuration file
    cat > "$redis_conf" << EOL
# Redis configuration for $app_name
# Generated by UDS Redis Manager

# Basic settings
port ${REDIS_PORT}
bind 0.0.0.0
protected-mode yes
daemonize no
supervised no

# Memory settings
maxmemory ${REDIS_MAX_MEMORY}
maxmemory-policy allkeys-lru

# Persistence settings
dir /data
appendonly yes
appendfsync everysec
EOL

    # Add password if enabled
    if [ -n "$redis_password" ]; then
      echo "requirepass $redis_password" >> "$redis_conf"
      
      # Add password to environment variables for the application
      local updated_env_vars=$(echo "$ENV_VARS" | jq --arg pwd "$redis_password" '. + {"REDIS_PASSWORD": $pwd}')
      ENV_VARS="$updated_env_vars"
      export ENV_VARS
      
      uds_log "Redis password configured for $app_name" "info"
    fi
    
    # Apply secure permissions
    uds_secure_permissions "$redis_conf" 600
  fi
  
  # Set up Redis data directory
  local redis_data_dir="${REDIS_DATA_DIR}/${app_name}"
  mkdir -p "$redis_data_dir"
  uds_secure_permissions "$redis_data_dir" 700
  
  # Add Redis volumes to the deployment
  if [ -n "$VOLUMES" ]; then
    VOLUMES="${VOLUMES},${redis_data_dir}:/data"
  else
    VOLUMES="${redis_data_dir}:/data"
  fi
  
  # Add config volume
  VOLUMES="${VOLUMES},${redis_conf}:/usr/local/etc/redis/redis.conf"
  export VOLUMES
  
  # Set Redis to use config file
  local updated_env_vars=$(echo "$ENV_VARS" | jq '. + {"REDIS_CONFIG": "/usr/local/etc/redis/redis.conf"}')
  ENV_VARS="$updated_env_vars"
  export ENV_VARS
  
  uds_log "Redis setup completed for $app_name" "info"
  return 0
}

# Check Redis health after deployment
plugin_redis_check() {
  local app_name="$1"
  local app_dir="$2"
  
  # Only process Redis deployments
  if [[ "$IMAGE" != *"redis"* ]]; then
    return 0
  fi
  
  uds_log "Checking Redis status for $app_name" "info"
  
  # Get container name
  local container_name="${app_name}-app"
  if [[ "$app_name" != *"-redis"* ]]; then
    container_name="${app_name}-redis"
  fi
  
  # Check if container is running
  if ! docker ps -q --filter "name=$container_name" | grep -q .; then
    uds_log "Redis container $container_name is not running" "error"
    # Get container logs if it exists but failed
    if docker ps -a -q --filter "name=$container_name" | grep -q .; then
      uds_log "Redis container logs (last 20 lines):" "info"
      docker logs --tail=20 "$container_name" || true
      
      # Check container status
      local status=$(docker inspect --format='{{.State.Status}}' "$container_name" 2>/dev/null)
      local exit_code=$(docker inspect --format='{{.State.ExitCode}}' "$container_name" 2>/dev/null)
      uds_log "Container status: $status, exit code: $exit_code" "info"
    fi
    return 1
  fi
  
  # Run Redis ping command
  local redis_password=""
  if [ "${REDIS_PASSWORD_ENABLED}" = "true" ]; then
    redis_password=$(grep "requirepass" "${REDIS_CONFIG_DIR}/${app_name}.conf" | awk '{print $2}')
  fi
  
  if [ -n "$redis_password" ]; then
    if ! docker exec "$container_name" redis-cli -a "$redis_password" ping | grep -q "PONG"; then
      uds_log "Redis health check failed for $app_name" "error"
      return 1
    fi
  else
    if ! docker exec "$container_name" redis-cli ping | grep -q "PONG"; then
      uds_log "Redis health check failed for $app_name" "error"
      return 1
    fi
  fi
  
  uds_log "Redis is healthy for $app_name" "success"
  return 0
}

# Backup Redis data before cleanup
plugin_redis_backup() {
  local app_name="$1"
  local app_dir="$2"
  
  # Only process Redis deployments
  if [[ "$IMAGE" != *"redis"* ]]; then
    return 0
  fi
  
  # Check if backup is enabled
  if [ "${REDIS_BACKUP_ENABLED}" != "true" ]; then
    return 0
  fi
  
  uds_log "Backing up Redis data for $app_name" "info"
  
  # Create backup directory with timestamp
  local backup_time=$(date +%Y%m%d%H%M%S)
  local backup_dir="${REDIS_BACKUP_DIR}/${app_name}_${backup_time}"
  mkdir -p "$backup_dir"
  
  # Copy Redis data files
  cp -r "${REDIS_DATA_DIR}/${app_name}"/* "$backup_dir/" || {
    uds_log "Failed to back up Redis data for $app_name" "error"
    return 1
  }
  
  uds_log "Redis data backed up to $backup_dir" "success"
  return 0
}
